# -*- coding: utf-8 -*-
"""Copy of Vehicle Routing Problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WucHs8N-wJJj7Tn2gnba_OxIR3jLQfur
"""

#TASK 1 - Install matplotlib and deap
#       - Import all necessary libraries
!pip install matplotlib deap

import random
import numpy as np
import matplotlib.pyplot as plt
from deap import base, creator, tools, algorithms

# TODO: Task 2 - Define the number of locations and vehicles
import random
num_locations = 10 # Define the number of locations (eg 10)

locations = [(random.randint(0, 100), random.randint(0, 100)) for i in range(num_locations)]
# Create a list of tuples representing location coordinates -
            # try to use a random number generator
            # (x, y) could be between 0 and 100

depot = (50,50)# Define the coordinates for the depot

num_vehicles = 3# Define the number of vehicles - (eg 3)

# TASK 3 - Genetic Algorithm Setup
       # - Figure out how to represent an individual OR encode an individual

# Genetic Algorithm setup
creator.create("FitnessMin", base.Fitness, weights=(-1.0,-1))
creator.create("Individual", list, fitness=creator.FitnessMin)

#TASK 4 - Starting with the toolbox and tools
toolbox = base.Toolbox()
toolbox.register("indices", random.sample, range(num_locations), num_locations)
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)#finish defining how to build an individual)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)#finish defining how to build an population)

#task 5 and 6
def evalVRP(individual):
    total_distance = 0
    distances = []  # Track distance traveled by each vehicle for balance calculation
    # Split the list of locations among vehicles, ensuring each starts and ends at the depot
    for i in range(num_vehicles):

        vehicle_route = [depot] + [locations[individual[j]] for j in range(i, len(individual), num_vehicles)] + [depot]

        # Calculate total distance traveled by this vehicle
        vehicle_distance = 0
        for k in range(len(vehicle_route) - 1):
           vehicle_distance += np.sqrt((vehicle_route[k+1][0] - vehicle_route[k][0])**2 + (vehicle_route[k+1][1] - vehicle_route[k][1])**2)



        total_distance += vehicle_distance
        distances.append(vehicle_distance)

    balance_penalty = np.std(distances)  # Use standard deviation of distances as a penalty for imbalance among vehicles
    return total_distance, balance_penalty

toolbox.register("evaluate", evalVRP)

# TODO: Task 7 - Configure the genetic operators
toolbox.register("mate", tools.cxPartialyMatched)# Choose and configure a crossover method)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3) # Choose and configure a selection method)

# Plotting Function
def plot_routes(individual, title="Routes"):
    #TODO: Task 5 - Write a function to visualize the routes - just plot the points and lines for each vehicle
    depot_x, depot_y = depot
    plt.scatter(depot_x, depot_y, c='red', marker='s', s=100, label='Depot')
    for i in range(num_vehicles):
        truck_route = [depot] + [locations[individual[j]] for j in range(i, len(individual), num_vehicles)] + [depot]
        x_coords, y_coords = zip(*truck_route)
        plt.plot(x_coords, y_coords, marker = 'o', linestyle = '-', linewidth = 2, markersize = 5)
        plt.legend()
    plt.title(title)
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.show()
plot_routes([0,1,2,3,4,5,6,7,8,9])

def main():
    random.seed(42)  # Seed for reproducibility
    pop = toolbox.population(n=300)  # Generate initial population
    hof = tools.HallOfFame(1)  # Hall of Fame to store the best individual

    # Setup statistics to track
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("min", np.min)

    # Run the genetic algorithm
    algorithms.eaSimple(pop, toolbox, 0.7, 0.2, 300, stats=stats, halloffame=hof)

    # Plot the best route found
    plot_routes(hof[0], "Optimal Route")
    return pop, stats, hof

if __name__ == "__main__":
    main()